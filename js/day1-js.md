# 数据类型
- 1.(基本的数据类型，复杂的数据类型);2.（值类型，引用类型）
- 5个基本的数据类型：字符串、数字、布尔、null、undefined;复杂的数据类型：对象（Object）
- 值类型:存储的就是数据本身的变量：字符串、数字、布尔、null、undefined;
- 值类型赋值：直接将存储的数据复制一份进行赋值，两份数据在内存中完全独立。
- 引用类型：存储的是数据在内存的中的地址：Object（数据在内存中单独存储，就是引用类型数据）
- 引用类型赋值：将变量中存储的地址复制一份单独存储，但是两个变量共享同一个对象，修改其中一个对象，另一个引用访问时，也会访问到修改后的对象
    - 注意：如果引用类型做函数的参数，if函数内部重新创捷对象，为该形参赋值，那么两个对象将不再有关系，修改其中一个，另一个不受影响

## null，undefined的区别
- 不同点：
  - null表示空值没有对象(只能存一个对象)，undefined表示“未定义”
  - undefined==null ture；undefined===null false(数据类型不同不全等，null的数据类型是对象，undefined的数据类型是undefined)
  - Number(undefieng)=NaN;Number(null)=0
- 相同点：
  - null或undefined和其他任何数据类型比较都不相等
  - 在if语句中，undefined和null，都会被自动转为false

## 数据类型的判断
- typeof 操作符
  - 局限性：不能具体检查Object下细分的类型
  - 例子
    - typeof  undefined    //Undefined
    - typeof  null        //Object （因为null类型被当做一个空对象引用）
    - typeof    { }      //Object
    - typeof    [ ]     //Object
  - 对一个值使用typeof操作符返回对应数据类型的字符串
  - 例子
    - console.log(typeof(typeof [])) //"string"
- 判断已知对象类型的方法： instanceof操作符（只用于对象）
![](index_files/4b8563c1-759a-4939-acf3-07a539dd2dca.png)

## 继承
- 原型链继承
  - 核心思想：拿父类实例来当子类原型对象（重写子类的原型对象或者理解成子类的原型指向了另一个对象，不再是默认原型（Object的实例，其内部指针指向Object.prototype））
  - 缺点：1、原型对象的引用属性是所有实例`共享的`（解释：子类有两个实例对象，其中一个实例对象引用原型对象的属性，并改变属性。则另一个实例对象引用原型对象的属性就随之改变）2、创建子类实例时，无法向父类构造函数传参
  - eg：
  ![](index_files/b21a389f-87f4-4bb2-ba86-900fafa3a352.png)
- 借用构造函数  (apply(),call())
  - 核心思想:借父类的构造函数来增强子类实例(等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）)
  - 优点：解决了原型链继承两个缺点
  - 缺点：无法实现函数复用，每个子类实例都持有一个新的fun函数，太多了就会影响性能，内存爆炸
  - eg：![](index_files/f77e74c2-fa9c-48fd-8c27-15145d70537e.png)
- 组合继承 
  - 核心思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承（让不同的实例分别拥有自己的属性，又可以使用相同的方法）
  - 优点：1.不存在引用属性共享问题,2.可传参,3.函数可复用

## call() 和 apply() 的含义和区别？
- 含义：每个函数包含两个非继承而来的方法，在特定的作用域中调用此函数，等于设置了函数体内this对象的值。（作用相同）
- 区别:接收参数的方式不同
  - apply()接收两个参数：`运行函数的作用域(this)`，参数数组；参数数组可以是Array实例也可以是arguments对象
  - call()第一个参数是：运行函数的作用域(this),其余参数直接传递给函数（参数必须逐个列举出来）
- 真正强大的地方：能够`扩充`函数赖以运行的`作用域`



